import yaml from 'js-yaml';

/**
 * Wrapper for js-yaml load to be used in client components
 */
export const yamlToJson = (yamlString: string): Record<string, unknown> => {
    const result = yaml.load(yamlString);
    if (typeof result !== 'object' || result === null) {
        throw new Error('Invalid YAML: must resolve to an object');
    }
    return result as Record<string, unknown>;
};

/**
 * Parses XML string to JSON.
 * Handles the specific <item> array format generated by promptNodesToXml,
 * but is robust enough for generic XML.
 */
export const xmlToJson = (xmlString: string): Record<string, unknown> => {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlString, "text/xml");

    const parseNode = (node: Node): unknown => {
        // Handle Text nodes
        if (node.nodeType === Node.TEXT_NODE) {
            const trimmed = node.nodeValue?.trim();
            if (!trimmed) return null;
            return trimmed;
        }

        // Handle Elements
        if (node.nodeType === Node.ELEMENT_NODE) {
            const element = node as Element;
            const obj: Record<string, unknown> = {};
            let hasChildren = false;
            let textContent = '';

            // Check for text-only content
            if (element.childNodes.length === 1 && element.childNodes[0].nodeType === Node.TEXT_NODE) {
                return element.childNodes[0].nodeValue;
            }

            // Process children
            const childNodes = Array.from(element.childNodes);
            const items: unknown[] = []; // For array collection

            childNodes.forEach(child => {
                if (child.nodeType === Node.TEXT_NODE) {
                    const val = child.nodeValue?.trim();
                    if (val) textContent = val; // Keep explicit text if mixed (simplified)
                    return;
                }
                
                if (child.nodeType === Node.ELEMENT_NODE) {
                    hasChildren = true;
                    const childName = child.nodeName;
                    const childValue = parseNode(child);

                    // Specific logic for <item> arrays from our generator
                    if (childName === 'item') {
                        items.push(childValue);
                    } else {
                        if (obj[childName]) {
                            if (Array.isArray(obj[childName])) {
                                (obj[childName] as unknown[]).push(childValue);
                            } else {
                                obj[childName] = [obj[childName], childValue];
                            }
                        } else {
                            obj[childName] = childValue;
                        }
                    }
                }
            });

            if (items.length > 0) {
                if (!Object.keys(obj).length) return items;
                return items;
            }

            if (!hasChildren && textContent) {
                return textContent;
            }
            
            return obj;
        }
        return null;
    };

    const root = xmlDoc.documentElement;
    if (!root) throw new Error("Invalid XML");
    
    const result = parseNode(root);
    
    if (root.nodeName === 'prompt' && typeof result === 'object' && result !== null && !Array.isArray(result)) {
        return result as Record<string, unknown>;
    }
    
    return { [root.nodeName]: result };
};

/**
 * Parses Markdown string (generated by promptNodesToMarkdown) to JSON.
 * Expects Heading structure (## Key) and Lists (- Item).
 */
export const markdownToJson = (md: string): Record<string, unknown> => {
  const lines = md.split('\n');
  const root: Record<string, unknown> = {};
  
  // Stack to track nesting. 
  // Level 1 is the virtual root for ## (Level 2) headers.
  // Items in stack: { level, container, key }
  // where 'container' is the parent object, and 'key' is the key IN that parent that points to the current object.
  // Note: 'obj' property in stack item would be redundant if we have reference to parent+key, 
  // but accessing parent[key] is safer to allow type changes (obj -> array -> string).
  
  // We actually want stack[0] to represent the context where we add top-level keys.
  // Our generator creates ## Key (Level 2).
  // So we initialize stack with a virtual level 1 context that points to 'root'.
  // When we see ##, level is 2. We look for parent with level < 2. That is stack[0] (level 1).
  // Parent container is stack[0].container['root'] (which is our actual root obj).
  
  // Let's adjust:
  // Stack items represent the "Active Object".
  // Level 1: The Root Object itself.
  
  const realStack: { level: number; obj: Record<string, unknown>; parent: Record<string, unknown>; keyInParent: string }[] = [
     { level: 1, obj: root, parent: { 'virtual': root }, keyInParent: 'virtual' }
  ];

  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed) continue;
    
    // 1. Heading Detection (## Key)
    const headingMatch = line.match(/^(#+)\s+(.*)$/);
    if (headingMatch) {
        const level = headingMatch[1].length;
        const key = headingMatch[2].trim();
        
        // Pop stack until we find the strictly direct parent (level < current)
        while (realStack.length > 0 && realStack[realStack.length - 1].level >= level) {
            realStack.pop();
        }
        
        if (realStack.length === 0) {
            // Should not happen if we start with level 1 and headers are >= 2
            // But if markdown starts with # (level 1), we might replace root?
            // Let's handle gracefully.
             realStack.push({ level: 1, obj: root, parent: { 'virtual': root }, keyInParent: 'virtual' });
        }

        const parentContext = realStack[realStack.length - 1];
        
        // Create new object for this key
        const newObj: Record<string, unknown> = {};
        
        // If parent is an array? (Should not happen in this specific MD flavor where Headers are keys)
        // But if we had mixed content... assume object for now.
        if (Array.isArray(parentContext.obj)) {
            // Cannot add named property to array
            // This parser assumes structural integrity matching the generator
        } else {
            parentContext.obj[key] = newObj;
        }
        
        // Push new context
        realStack.push({ 
            level, 
            obj: newObj, 
            parent: parentContext.obj, 
            keyInParent: key 
        });
        continue;
    }
    
    // 2. List Item Detection (- Item)
    const listMatch = line.match(/^-\s+(.*)$/);
    if (listMatch) {
        const value = listMatch[1].trim();
        const currentContext = realStack[realStack.length - 1];
        
        // We are 'inside' currentContext.obj (e.g. under '## Key')
        // If this is the first list item, convert currentContext.obj from {} to []
        
        const parent = currentContext.parent;
        const key = currentContext.keyInParent;
        
        let targetArray: unknown[] = [];
        
        if (Array.isArray(parent[key])) {
            targetArray = parent[key] as unknown[];
        } else {
            // Check if it's an empty object (freshly created by Header)
            // If it has keys, we have mixed content? (Not supported, assume empty)
            targetArray = [];
            parent[key] = targetArray;
            
            // Update reference in stack?
            // currentContext.obj reference is now stale (points to old {}).
            // We shouldn't use currentContext.obj for lists anymore.
        }
        
        // Add value
        // Attempt to detect JSON in markdown list item (e.g. ```json ... ``` or simple object)
        // The generator produces "- value" or blocks.
        // Simple value for now.
        targetArray.push(value);
        continue;
    }
    
    // 3. JSON Block Detection (```json ... ```)
    // This simple line-by-line parser fails on multiline blocks.
    // For this task, we assume simple text values or list items.
    // If we encounter text that is not header or list:
    
    // 4. Text Content
    // Assign as string value to the current key
    const currentContext = realStack[realStack.length - 1];
    const parent = currentContext.parent;
    const key = currentContext.keyInParent;
    
    // If we already have an object/array, this might overwrite or append?
    // Generator: 
    // Key
    // Value
    // -> Key: "Value"
    
    // If it's empty object, replace with string.
    if (Object.keys(currentContext.obj).length === 0 && !Array.isArray(parent[key])) {
        parent[key] = trimmed;
    } else {
        // If it already has content, maybe append? (Multiline string)
        if (typeof parent[key] === 'string') {
            parent[key] = parent[key] + '\n' + trimmed;
        }
    }
  }
  
  return root;
};
